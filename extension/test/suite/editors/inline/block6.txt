SEARCH
	public async applyStreamContent(content: string): Promise<boolean> {
		await this.documentReadyPromise
		if (!this.currentDocumentState) {
			throw new Error("No active document")
		}

		try {
			const document = await this.getDocument()
			if (!document) return false

			const editor = vscode.window.activeTextEditor
			if (!editor || editor.document.uri.toString() !== document.uri.toString()) {
				return false
			}

			// Initialize streaming if needed
			if (!this.currentDocumentState.isStreaming) {
				this.currentDocumentState.isStreaming = true
				this.currentDocumentState.currentContent = this.currentDocumentState.originalContent

				// Display original content first
				const initialEdit = new vscode.WorkspaceEdit()
				initialEdit.replace(
					document.uri,
					new vscode.Range(0, 0, document.lineCount, 0),
					this.currentDocumentState.originalContent
				)
				await vscode.workspace.applyEdit(initialEdit)
				await this.refreshEditor()
				await new Promise(resolve => setTimeout(resolve, 100))
			}

			// Split content into lines
			const newLines = content.split("\n")
			const originalLines = this.currentDocumentState.originalContent.split("\n")
			const currentLines = this.currentDocumentState.currentContent.split("\n")

			// Create chunks of changes (max 5 lines per chunk)
			const chunkSize = 5
			const chunks: Array<{ start: number; end: number; content: string[] }> = []
			let currentChunk: { start: number; end: number; content: string[] } | null = null

			for (let i = 0; i < newLines.length; i++) {
				if (i >= currentLines.length || currentLines[i] !== newLines[i]) {
					if (!currentChunk) {
						currentChunk = { start: i, end: i, content: [newLines[i]] }
					} else if (i === currentChunk.end + 1 && chunks.length < chunkSize) {
						currentChunk.end = i
						currentChunk.content.push(newLines[i])
					} else {
						chunks.push(currentChunk)
						currentChunk = { start: i, end: i, content: [newLines[i]] }
					}
				} else if (currentChunk) {
					chunks.push(currentChunk)
					currentChunk = null
				}
			}

			if (currentChunk) {
				chunks.push(currentChunk)
			}

			// Apply chunks with visual feedback
			for (const chunk of chunks) {
				const workspaceEdit = new vscode.WorkspaceEdit()
				const chunkContent = chunk.content.join("\n")
				const startPos = new vscode.Position(chunk.start, 0)
				const endPos = chunk.end < currentLines.length
					? new vscode.Position(chunk.end, currentLines[chunk.end].length)
					: new vscode.Position(chunk.end, 0)

				workspaceEdit.replace(document.uri, new vscode.Range(startPos, endPos), chunkContent)
				await vscode.workspace.applyEdit(workspaceEdit)

				// Update current content
				const updatedLines = [...this.currentDocumentState.currentContent.split("\n")]
				for (let i = 0; i < chunk.content.length; i++) {
					const lineIndex = chunk.start + i
					if (lineIndex < updatedLines.length) {
						updatedLines[lineIndex] = chunk.content[i]
					} else {
						updatedLines.push(chunk.content[i])
					}
				}
				this.currentDocumentState.currentContent = updatedLines.join("\n")

				// Refresh decorations and scroll
				await this.refreshEditor()
				await this.scrollToRange(editor, new vscode.Range(startPos, endPos))
				await new Promise(resolve => setTimeout(resolve, 50))
			}

			// Handle case where new content is shorter
			if (newLines.length < currentLines.length) {
				const deleteEdit = new vscode.WorkspaceEdit()
				deleteEdit.delete(document.uri, new vscode.Range(
					new vscode.Position(newLines.length, 0),
					new vscode.Position(currentLines.length, 0)
				))
				await vscode.workspace.applyEdit(deleteEdit)
				this.currentDocumentState.currentContent = newLines.join("\n")
				await this.refreshEditor()
			}

			return true
=======
REPLACE
	public async applyStreamContent(content: string): Promise<boolean> {
		await this.documentReadyPromise
		if (!this.currentDocumentState) {
			throw new Error("No active document")
		}

		try {
			const document = await this.getDocument()
			if (!document) return false

			const editor = vscode.window.activeTextEditor
			if (!editor || editor.document.uri.toString() !== document.uri.toString()) {
				return false
			}

			// Initialize streaming if needed
			if (!this.currentDocumentState.isStreaming) {
				this.currentDocumentState.isStreaming = true
				
				// Show original content first
				const workspaceEdit = new vscode.WorkspaceEdit()
				workspaceEdit.replace(
					document.uri,
					new vscode.Range(0, 0, document.lineCount, 0),
					this.currentDocumentState.originalContent
				)
				await vscode.workspace.applyEdit(workspaceEdit)
				this.currentDocumentState.currentContent = this.currentDocumentState.originalContent
				await this.refreshEditor()
				await new Promise(resolve => setTimeout(resolve, 100))
			}

			// Split both contents into lines
			const newLines = content.split("\n")
			const originalLines = this.currentDocumentState.originalContent.split("\n")

			// Create combined content with both versions
			const combinedLines: string[] = []
			const maxLines = Math.max(originalLines.length, newLines.length)

			for (let i = 0; i < maxLines; i++) {
				if (i < originalLines.length) {
					combinedLines.push(originalLines[i])
				}
				if (i < newLines.length && (i >= originalLines.length || originalLines[i] !== newLines[i])) {
					combinedLines.push(newLines[i])
				}
			}

			// Apply combined content
			const workspaceEdit = new vscode.WorkspaceEdit()
			workspaceEdit.replace(
				document.uri,
				new vscode.Range(0, 0, document.lineCount, 0),
				combinedLines.join("\n")
			)
			await vscode.workspace.applyEdit(workspaceEdit)

			// Update current content and refresh decorations
			this.currentDocumentState.currentContent = content
			await this.refreshEditor()

			// Find the last different line for scrolling
			let lastDiffLine = 0
			for (let i = 0; i < maxLines; i++) {
				if (i >= originalLines.length || i >= newLines.length || originalLines[i] !== newLines[i]) {
					lastDiffLine = i
				}
			}

			// Scroll to the last difference
			const scrollRange = new vscode.Range(
				new vscode.Position(lastDiffLine, 0),
				new vscode.Position(lastDiffLine + 1, 0)
			)
			await this.scrollToRange(editor, scrollRange)

			return true
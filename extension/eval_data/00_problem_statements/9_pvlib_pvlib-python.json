{
    "repo": "pvlib/pvlib-python",
    "instance_id": "pvlib__pvlib-python-1606",
    "base_commit": "c78b50f4337ecbe536a961336ca91a1176efc0e8",
    "patch": "diff --git a/pvlib/tools.py b/pvlib/tools.py\n--- a/pvlib/tools.py\n+++ b/pvlib/tools.py\n@@ -341,6 +341,8 @@ def _golden_sect_DataFrame(params, lower, upper, func, atol=1e-8):\n     --------\n     pvlib.singlediode._pwr_optfcn\n     \"\"\"\n+    if np.any(upper - lower < 0.):\n+        raise ValueError('upper >= lower is required')\n \n     phim1 = (np.sqrt(5) - 1) / 2\n \n@@ -349,16 +351,8 @@ def _golden_sect_DataFrame(params, lower, upper, func, atol=1e-8):\n     df['VL'] = lower\n \n     converged = False\n-    iterations = 0\n \n-    # handle all NaN case gracefully\n-    with warnings.catch_warnings():\n-        warnings.filterwarnings(action='ignore',\n-                                message='All-NaN slice encountered')\n-        iterlimit = 1 + np.nanmax(\n-            np.trunc(np.log(atol / (df['VH'] - df['VL'])) / np.log(phim1)))\n-\n-    while not converged and (iterations <= iterlimit):\n+    while not converged:\n \n         phi = phim1 * (df['VH'] - df['VL'])\n         df['V1'] = df['VL'] + phi\n@@ -373,22 +367,16 @@ def _golden_sect_DataFrame(params, lower, upper, func, atol=1e-8):\n \n         err = abs(df['V2'] - df['V1'])\n \n-        # works with single value because err is np.float64\n-        converged = (err[~np.isnan(err)] < atol).all()\n-        # err will be less than atol before iterations hit the limit\n-        # but just to be safe\n-        iterations += 1\n-\n-    if iterations > iterlimit:\n-        raise Exception(\"Iterations exceeded maximum. Check that func\",\n-                        \" is not NaN in (lower, upper)\")  # pragma: no cover\n+        # handle all NaN case gracefully\n+        with warnings.catch_warnings():\n+            warnings.filterwarnings(action='ignore',\n+                                    message='All-NaN slice encountered')\n+            converged = np.all(err[~np.isnan(err)] < atol)\n \n-    try:\n-        func_result = func(df, 'V1')\n-        x = np.where(np.isnan(func_result), np.nan, df['V1'])\n-    except KeyError:\n-        func_result = np.full_like(upper, np.nan)\n-        x = func_result.copy()\n+    # best estimate of location of maximum\n+    df['max'] = 0.5 * (df['V1'] + df['V2'])\n+    func_result = func(df, 'max')\n+    x = np.where(np.isnan(func_result), np.nan, df['max'])\n \n     return func_result, x\n \n",
    "test_patch": "diff --git a/pvlib/tests/test_tools.py b/pvlib/tests/test_tools.py\n--- a/pvlib/tests/test_tools.py\n+++ b/pvlib/tests/test_tools.py\n@@ -45,6 +45,22 @@ def test__golden_sect_DataFrame_vector():\n     v, x = tools._golden_sect_DataFrame(params, lower, upper,\n                                         _obj_test_golden_sect)\n     assert np.allclose(x, expected, atol=1e-8)\n+    # some upper and lower bounds equal\n+    params = {'c': np.array([1., 2., 1.]), 'n': np.array([1., 1., 1.])}\n+    lower = np.array([0., 0.001, 1.])\n+    upper = np.array([1., 1.2, 1.])\n+    expected = np.array([0.5, 0.25, 1.0])  # x values for maxima\n+    v, x = tools._golden_sect_DataFrame(params, lower, upper,\n+                                        _obj_test_golden_sect)\n+    assert np.allclose(x, expected, atol=1e-8)\n+    # all upper and lower bounds equal, arrays of length 1\n+    params = {'c': np.array([1.]), 'n': np.array([1.])}\n+    lower = np.array([1.])\n+    upper = np.array([1.])\n+    expected = np.array([1.])  # x values for maxima\n+    v, x = tools._golden_sect_DataFrame(params, lower, upper,\n+                                        _obj_test_golden_sect)\n+    assert np.allclose(x, expected, atol=1e-8)\n \n \n def test__golden_sect_DataFrame_nans():\n",
    "problem_statement": "golden-section search fails when upper and lower bounds are equal\n**Describe the bug**\r\nI was using pvlib for sometime now and until now I was always passing a big dataframe containing readings of a long period. Because of some changes in our software architecture, I need to pass the weather readings as a single reading (a dataframe with only one row) and I noticed that for readings that GHI-DHI are zero pvlib fails to calculate the output and returns below error while the same code executes correctly with weather information that has non-zero GHI-DHI:\r\n```python\r\nimport os\r\nimport pathlib\r\nimport time\r\nimport json\r\nfrom datetime import datetime\r\nfrom time import mktime, gmtime\r\n\r\nimport pandas as pd\r\n\r\nfrom pvlib import pvsystem\r\nfrom pvlib import location as pvlocation\r\nfrom pvlib import modelchain\r\nfrom pvlib.temperature import TEMPERATURE_MODEL_PARAMETERS as PARAMS # not used -- to remove\r\nfrom pvlib.bifacial.pvfactors import pvfactors_timeseries\r\nfrom pvlib.temperature import TEMPERATURE_MODEL_PARAMETERS\r\n\r\nclass PV:\r\n    def pv_transform_time(self, val):\r\n        # tt = gmtime(val / 1000)\r\n        tt = gmtime(val)\r\n        dd = datetime.fromtimestamp(mktime(tt))\r\n        timestamp = pd.Timestamp(dd)\r\n        return timestamp\r\n\r\n    def __init__(self, model: str, inverter: str, latitude: float, longitude: float, **kwargs):\r\n        # super().__init__(**kwargs)\r\n\r\n        temperature_model_parameters = TEMPERATURE_MODEL_PARAMETERS[\"sapm\"][\r\n            \"open_rack_glass_glass\"\r\n        ]\r\n        # Load the database of CEC module model parameters\r\n        modules = pvsystem.retrieve_sam(\"cecmod\")\r\n        # Load the database of CEC inverter model parameters\r\n        inverters = pvsystem.retrieve_sam(\"cecinverter\")\r\n\r\n\r\n        # A bare bone PV simulator\r\n\r\n        # Load the database of CEC module model parameters\r\n        modules = pvsystem.retrieve_sam('cecmod')\r\n        inverters = pvsystem.retrieve_sam('cecinverter')\r\n        module_parameters = modules[model]\r\n        inverter_parameters = inverters[inverter]\r\n\r\n        location = pvlocation.Location(latitude=latitude, longitude=longitude)\r\n        system = pvsystem.PVSystem(module_parameters=module_parameters, inverter_parameters=inverter_parameters, temperature_model_parameters=temperature_model_parameters)\r\n        self.modelchain = modelchain.ModelChain(system, location, aoi_model='no_loss', spectral_model=\"no_loss\")\r\n\r\n    def process(self, data):\r\n        weather = pd.read_json(data)\r\n        # print(f\"raw_weather: {weather}\")\r\n        weather.drop('time.1', axis=1, inplace=True)\r\n        weather['time'] = pd.to_datetime(weather['time']).map(datetime.timestamp) # --> this works for the new process_weather code and also the old weather file\r\n        weather[\"time\"] = weather[\"time\"].apply(self.pv_transform_time)\r\n        weather.index = weather[\"time\"]\r\n        # print(f\"weather: {weather}\")\r\n        # print(weather.dtypes)\r\n        # print(weather['ghi'][0])\r\n        # print(type(weather['ghi'][0]))\r\n\r\n        # simulate\r\n        self.modelchain.run_model(weather)\r\n        # print(self.modelchain.results.ac.to_frame().to_json())\r\n        print(self.modelchain.results.ac)\r\n\r\n\r\n# good data\r\ngood_data = \"{\\\"time\\\":{\\\"12\\\":\\\"2010-01-01 13:30:00+00:00\\\"},\\\"ghi\\\":{\\\"12\\\":36},\\\"dhi\\\":{\\\"12\\\":36},\\\"dni\\\":{\\\"12\\\":0},\\\"Tamb\\\":{\\\"12\\\":8.0},\\\"WindVel\\\":{\\\"12\\\":5.0},\\\"WindDir\\\":{\\\"12\\\":270},\\\"time.1\\\":{\\\"12\\\":\\\"2010-01-01 13:30:00+00:00\\\"}}\"\r\n\r\n# data that causes error\r\ndata = \"{\\\"time\\\":{\\\"4\\\":\\\"2010-01-01 05:30:00+00:00\\\"},\\\"ghi\\\":{\\\"4\\\":0},\\\"dhi\\\":{\\\"4\\\":0},\\\"dni\\\":{\\\"4\\\":0},\\\"Tamb\\\":{\\\"4\\\":8.0},\\\"WindVel\\\":{\\\"4\\\":4.0},\\\"WindDir\\\":{\\\"4\\\":240},\\\"time.1\\\":{\\\"4\\\":\\\"2010-01-01 05:30:00+00:00\\\"}}\"\r\np1 = PV(model=\"Trina_Solar_TSM_300DEG5C_07_II_\", inverter=\"ABB__MICRO_0_25_I_OUTD_US_208__208V_\", latitude=51.204483, longitude=5.265472)\r\np1.process(good_data)\r\nprint(\"=====\")\r\np1.process(data)\r\n```\r\nError:\r\n```log\r\n$ python3 ./tmp-pv.py \r\ntime\r\n2010-01-01 13:30:00    7.825527\r\ndtype: float64\r\n=====\r\n/home/user/.local/lib/python3.10/site-packages/pvlib/tools.py:340: RuntimeWarning: divide by zero encountered in divide\r\n  np.trunc(np.log(atol / (df['VH'] - df['VL'])) / np.log(phim1)))\r\nTraceback (most recent call last):\r\n  File \"/home/user/workspace/enorch/simulator/simulator_processor/src/pv/./tmp-pv.py\", line 88, in <module>\r\n    p1.process(data)\r\n  File \"/home/user/workspace/enorch/simulator/simulator_processor/src/pv/./tmp-pv.py\", line 75, in process\r\n    self.modelchain.run_model(weather)\r\n  File \"/home/user/.local/lib/python3.10/site-packages/pvlib/modelchain.py\", line 1770, in run_model\r\n    self._run_from_effective_irrad(weather)\r\n  File \"/home/user/.local/lib/python3.10/site-packages/pvlib/modelchain.py\", line 1858, in _run_from_effective_irrad\r\n    self.dc_model()\r\n  File \"/home/user/.local/lib/python3.10/site-packages/pvlib/modelchain.py\", line 790, in cec\r\n    return self._singlediode(self.system.calcparams_cec)\r\n  File \"/home/user/.local/lib/python3.10/site-packages/pvlib/modelchain.py\", line 772, in _singlediode\r\n    self.results.dc = tuple(itertools.starmap(\r\n  File \"/home/user/.local/lib/python3.10/site-packages/pvlib/pvsystem.py\", line 931, in singlediode\r\n    return singlediode(photocurrent, saturation_current,\r\n  File \"/home/user/.local/lib/python3.10/site-packages/pvlib/pvsystem.py\", line 2826, in singlediode\r\n    out = _singlediode._lambertw(\r\n  File \"/home/user/.local/lib/python3.10/site-packages/pvlib/singlediode.py\", line 651, in _lambertw\r\n    p_mp, v_mp = _golden_sect_DataFrame(params, 0., v_oc * 1.14,\r\n  File \"/home/user/.local/lib/python3.10/site-packages/pvlib/tools.py\", line 364, in _golden_sect_DataFrame\r\n    raise Exception(\"Iterations exceeded maximum. Check that func\",\r\nException: ('Iterations exceeded maximum. Check that func', ' is not NaN in (lower, upper)')\r\n```\r\n\r\nI have to mention that for now the workaround that I am using is to pass the weather data as a dataframe with two rows, the first row is a good weather data that pvlib can process and the second row is the incoming weather reading (I can also post that code if you want).\r\n\r\n**Expected behavior**\r\nPVlib should have consistent behavior and regardless of GHI-DHI readings.\r\n\r\n**Versions:**\r\n```python\r\n>>> import pvlib\r\n>>> import pandas\r\n>>> pvlib.__version__\r\n'0.9.1'\r\n>>> pandas.__version__\r\n'1.4.3'\r\n``` \r\n - python: 3.10.6\r\n- OS: Ubuntu 22.04.1 LTS\n",
    "hints_text": "Confirmed. This appears to be an oversight in `pvlib.tools._golden_section_DataFrame` involving error messaging, likely introduced with #1089 .\r\n\r\nIn this code when processing the content of `data`, photocurrent is 0., hence the shunt resistance is infinite and v_oc is 0. That sets the range for the golden section search to be [0., 0.]. [iterlimit](https://github.com/pvlib/pvlib-python/blob/582b956c63c463e5178fbb7a88fa545fa5b1c257/pvlib/tools.py#L358) is then -infinity, which skips the loop (`iterations <= iterlimit`) but since `iterations > iterlimit` raises the \"Iterations exceeded...\" exception.\r\n",
    "created_at": "2022-12-07T21:12:08Z",
    "version": "0.8",
    "FAIL_TO_PASS": "[\"pvlib/tests/test_tools.py::test__golden_sect_DataFrame_vector\"]",
    "PASS_TO_PASS": "[\"pvlib/tests/test_tools.py::test_build_kwargs[keys0-input_dict0-expected0]\", \"pvlib/tests/test_tools.py::test_build_kwargs[keys1-input_dict1-expected1]\", \"pvlib/tests/test_tools.py::test_build_kwargs[keys2-input_dict2-expected2]\", \"pvlib/tests/test_tools.py::test_build_kwargs[keys3-input_dict3-expected3]\", \"pvlib/tests/test_tools.py::test__golden_sect_DataFrame[params0-0.0-1.0-0.5-_obj_test_golden_sect]\", \"pvlib/tests/test_tools.py::test__golden_sect_DataFrame[params1-0.0-1.0-0.07230200263994839-_obj_test_golden_sect]\", \"pvlib/tests/test_tools.py::test__golden_sect_DataFrame[params2-0.0-100.0-89.14332727531685-_obj_test_golden_sect]\", \"pvlib/tests/test_tools.py::test__golden_sect_DataFrame_atol\", \"pvlib/tests/test_tools.py::test__golden_sect_DataFrame_nans\", \"pvlib/tests/test_tools.py::test_degrees_to_index_1\"]",
    "environment_setup_commit": "ef8ad2fee9840a77d14b0dfd17fc489dd85c9b91"
}